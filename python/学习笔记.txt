eval(str)：去掉str的引号，成为一个列表、字典、元组



lambda 匿名函数
lambda 传入值: 功能区




series的index为行索引，name为列索引
series就是一行或一列数据
DataFrame为series的集合，可以理解为excel



pandas读取文件有时会改变字段类型
data.info()   查看字段类型
read_excel()方法内加converters参数(键值对)设置字段类型，如下：
data = pd.read_excel('文件', converters= {'uid': str})

astype()  改变字段类型
data['id'] = data['id'].astype(str)



data.to_excel()  导出为excel文件（index=False去掉DataFrame的行索引列）
data.to_excel('xx.xlsx', index=False)

data.to_csv()  导出为csv文件（常用为设置为txt文件,再用excel打开（打开时要设置格式））
data.to_csv('xx.csv', encoding='GB18030')
data.to_csv('xx.txt', sep='\t')



[] 相当于sql中的select

data['id']   筛选出单列数据
data[['id', 'content', 'uid']]  筛选出多列数据

data.iloc[2]  筛选出第2行数据
data.iloc[1:6]  筛选出第1行至第5行数据
data.iloc[1:6]['id']  筛选出第1行至第5行的id列数据

data[data['progress'] >= 100000]  筛选出data中progress大于100000的行

data.drop_duplicates()  数据去重（类似窗口函数为新建视图，默认不改变原数据）
data.drop_duplicates(subset=['content', 'uid'] , keep='last', inplace=False)
subset设置去重列，keep设置保留重复数据中首次出现或最后一次出现的数据，inplace为True时就会改变原数据



axis  DataFrame的轴，这里可以理解为方向
axis=0  相当于axis='index'，为纵轴，从上至下，行
axis=1  相当于axis='columns'，为横轴，从左至右，列

纵向拼接data和data2（axis=0 ）
concat_demo = pd.concat([data, data2], axis=0)

pd.merge(左表，右表，how='连接方式'，连接键)  表连接
# 两表需要连接的字段名相同时
pd.merge(concat_demo, user_level, how='inner', on='uid')
# 两表需要连接字段名不同时
pd.merge(concat_demo, user_level, how='inner', left_on='uid', right_on='user_id')




data.sort_values()  排序（ascending设置升降序，默认为True升序）
# 将date表依次按照uid升序、ctime降序排序
data.sort_values(by=['uid', 'ctime'], ascending=[True, False])



data.groupby()  分组（不直接生成DataFrame，生成一个DataFrameGroupBy类型实例对象（此对象类似字典），强行打印要遍历）
level_group.count()  对分组后的对象计算每个分组的数据数量

对分组后对象可直接使用聚合函数
分组后对某字段聚合使用双[]返回对象为DataFrame，单[]返回对象为Series
product_gp[['消耗']].sum()

count()        计数
nunique()   不重复计数（相同的只记作一次）

agg()  有多个聚合需求时使用
# 有多个需求
history.groupby('商品名称').agg(['max', 'mean'])
# 对不同字段有不同需求
history.groupby('商品名称').agg({'客单价': ['min', 'max'], '消耗': max})

transform()  窗口函数,操作列级别,类似于apply()
# transform计算出的结果可以赋回给每组每一个对应行
history.groupby('商品名称')[['roi']].transform(min) # 将该组的最小roi返回给该行
# apply计算出的结果不会返回给对应行,会返回对应的计算结果，但另外用lambda函数可以完成赋值操作
history['roi最小'] = history.groupby('商品名称')[['roi']].apply(min) # 计算每组的roi最小值，每组只返回一行值

rank() 排序函数
# 1.first
# 顺序排名 1,2,3,4
history['roi排名_first'] = history.groupby('商品名称')[['roi']].rank(ascending=False, method='first')
# 2.average
# 相同排名时取平均值  1, 2.5, 2.5, 4
# 3.min
# 相同排名时取较小值 1,2,2,4
# 4.max
# 相同排名时取较大值 1,3,3,4
# 5.dense
# 跳跃式 1,1,2,3



字符串方法操作DataFrame时，要在Series后加str方法转换，再用字符串方法

split() 字符串切割
# 原始拆分为多个Series，设置expand参数为true会变成DataFrame
history['广告计划名称'].str.split('_', expand=True)

contains()  过滤
# 过滤, reset_index重新设置行索引，drop=True参数去除原来的行索引列
history[history['商品名称'].str.contains('玩转')].reset_index(drop=True)

replace() 替换
# 用法一
history['商品名称'].str.replace('《', '【').str.replace('》', '】')
# 用法二，结合正则
history['商品名称'].str.replace(r'《(.*?)》', r'【\1】', regex=True)

extract() 取出正则匹配到的
history['广告计划名称'].str.extract(r'(.*?)_')



map()  操作Series
apply() 操作Series或DataFrame，操作DataFrame时值为一个个Series的传入（默认axis=0）
# history.apply(demo, axis=1, args=(coe,))    # args参数后为（）元组对象，且必须加逗号
applymap() 操作DataFrame，值一个个传入